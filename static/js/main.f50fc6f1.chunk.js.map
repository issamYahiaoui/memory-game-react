{"version":3,"sources":["cardImages.js","utils.js","components/CardImage.js","components/Card.js","components/GamePlayGround.js","App.js","serviceWorker.js","index.js"],"names":["cards","shuffleArray","array","sort","Math","random","Image","src","alt","style","className","props","Card","imageURL","isFlipped","canFlip","onClick","GamePlayGround","cardImages","useState","count","slice","map","id","uuid","flatMap","e","deepcopy","generatePlayGroundCards","setCards","setCanFlip","firstCard","setFirstCard","secondCard","setSecondCard","matchedCards","setMatchedCards","start","setStart","end","setEnd","tries","setTries","setCardFlipped","cardID","prevCard","card","setAllCardsFlipped","setCardCanFlip","resetFirstAndSecondCards","restart","prev","c","setAllCardsCanFlip","useEffect","setTimeout","firstCardID","secondCardID","onFailureGuess","size","length","window","onCardClick","key","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.f50fc6f1.chunk.js","sourcesContent":["const cards = [\n    \"clubs_10.png\", \"clubs_2.png\", \"clubs_3.png\", \"clubs_4.png\", \"clubs_5.png\",\n    \"clubs_6.png\", \"clubs_7.png\", \"clubs_8.png\", \"clubs_9.png\", \"clubs_A.png\",\n    \"clubs_J.png\", \"clubs_K.png\", \"clubs_Q.png\",\n    \"diamonds_10.png\", \"diamonds_2.png\", \"diamonds_3.png\", \"diamonds_4.png\",\n    \"diamonds_5.png\", \"diamonds_6.png\", \"diamonds_7.png\", \"diamonds_8.png\",\n    \"diamonds_9.png\", \"diamonds_A.png\", \"diamonds_J.png\", \"diamonds_K.png\",\n    \"diamonds_Q.png\",\n    \"hearts_10.png\", \"hearts_2.png\", \"hearts_3.png\", \"hearts_4.png\",\n    \"hearts_5.png\", \"hearts_6.png\", \"hearts_7.png\", \"hearts_8.png\",\n    \"hearts_9.png\", \"hearts_A.png\", \"hearts_J.png\", \"hearts_K.png\",\n    \"hearts_Q.png\",\n    \"spades_10.png\", \"spades_2.png\", \"spades_3.png\", \"spades_4.png\",\n    \"spades_5.png\", \"spades_6.png\", \"spades_7.png\", \"spades_8.png\",\n    \"spades_9.png\", \"spades_A.png\", \"spades_J.png\", \"spades_K.png\",\n    \"spades_Q.png\"\n];\n\nexport default cards;\n","import uuid from 'react-uuid';\nimport deepcopy from \"deepcopy\";\n\n const shuffleArray =(array)=>{\n    return array.sort(() => .5 - Math.random());\n}\nexport const generatePlayGroundCards = (count, cardImages)=> {\n\n    if (count % 2 !== 0)\n        throw \"Count must pair. but it is \" + count;\n\n    const cards = shuffleArray(cardImages)\n        .slice(0, count / 2)\n        .map(imageURL => ({\n            id: uuid(),\n            imageURL: \"images/cards/\" + imageURL,\n            isFlipped: false,\n            canFlip: true\n        }))\n        .flatMap(e => [e, {...deepcopy(e), id: uuid()}]);\n\n    return shuffleArray(cards);\n}\n","import React from \"react\";\n\nexport default  Image = ({ src, alt=\"\", style={}, className=\"\", ...props })=>{\n    return <img src={src} alt={alt} style={style} className={className} {...props}/>;\n}\n","import React from \"react\";\nimport Image from \"./CardImage\";\n\nexport default function Card({imageURL, isFlipped, canFlip,onClick}) {\n    return  <div className={\"card\" + (!isFlipped ? ' opened' : '') + (!canFlip ? ' matched' : '')} onClick={onClick}>\n        <div className=\"front\">\n            ?\n        </div>\n        <div className=\"back\">\n            <Image src={imageURL}/>\n        </div>\n    </div>;\n}\n","import React, {useState, useEffect} from 'react'\nimport {generatePlayGroundCards} from \"../utils\";\nimport Card from \"./Card\";\n\nconst size = 18\nconst GamePlayGround = ({cardImages}) => {\n\n    const [cards, setCards] = useState(generatePlayGroundCards(size, cardImages));\n    const [canFlip, setCanFlip] = useState(false);\n    const [firstCard, setFirstCard] = useState(null);\n    const [secondCard, setSecondCard] = useState(null);\n    const [matchedCards, setMatchedCards] = useState([]);\n    const [start, setStart] = useState(false);\n    const [end, setEnd] = useState(false);\n    const [tries, setTries] = useState(0);\n\n\n    //flip card\n    const setCardFlipped = (cardID, isFlipped) => {\n        setCards(prevCard => prevCard.map(card => {\n            if (card.id !== cardID)\n                return card;\n            return {...card, isFlipped};\n        }));\n    }\n    //flip all cards\n    const setAllCardsFlipped = (isFlipped) => {\n        setCards(prevCard => prevCard.map(card => {\n            return {...card, isFlipped};\n        }));\n    }\n\n    // lock/unlock card\n    const setCardCanFlip = (cardID, canFlip) => {\n        setCards(prevCard => prevCard.map(card => {\n            if (card.id !== cardID)\n                return card;\n            return {...card, canFlip};\n        }));\n    }\n    // lock/unlock all cards\n    const setAllCardsCanFlip = ( canFlip) => {\n        setCards(prev => prev.map(c => {\n            return {...c, canFlip};\n        }));\n    }\n\n\n    // reset the guess\n    const resetFirstAndSecondCards = () => {\n        setFirstCard(null);\n        setSecondCard(null);\n    }\n\n    // get score [tries ]\n    const getScore = () => {\n        // set number of tries\n        setTimeout(() => {\n            setTries(tries+1)\n        }, 1000);\n    }\n\n    // handle success on guess\n    const onSuccessGuess = () => {\n\n        setMatchedCards([...matchedCards, [firstCard, secondCard]])\n\n        setCardCanFlip(firstCard.id, false);\n        setCardFlipped(firstCard.id, false);\n        setCardCanFlip(secondCard.id, false);\n        setCardFlipped(secondCard.id, false);\n\n        resetFirstAndSecondCards();\n\n    }\n\n    // handle failure on guess\n    const onFailureGuess = () => {\n\n        const firstCardID = firstCard.id;\n        const secondCardID = secondCard.id;\n\n        setTimeout(() => {\n            setCardFlipped(firstCardID, true);\n        }, 1000);\n        setTimeout(() => {\n            setCardFlipped(secondCardID, true);\n        }, 1200);\n\n\n        resetFirstAndSecondCards();\n\n    }\n\n\n    // handle card click\n    const onCardClick = (card) => {\n        window.card = card\n\n\n        if (!canFlip)\n            return;\n        if (!card.canFlip)\n            return;\n\n        //click on same flipped card\n        if ((firstCard && (card.id === firstCard.id) || (secondCard && (card.id === secondCard.id))))\n            return;\n\n\n        setCardFlipped(card.id, false);\n\n        (firstCard) ? setSecondCard(card) : setFirstCard(card);\n    }\n\n\n\n    // initialize : flip all cards at the beginning\n    const initialize = () =>{\n        setTimeout(() => {\n            let index = 0;\n            setAllCardsFlipped(true)\n            setCanFlip(true) // unlock the flippping\n        }, 3000);\n    }\n\n\n    //restart the game\n    const restart = ()=>{\n        setAllCardsFlipped(true)\n        setAllCardsCanFlip(true)\n        setCanFlip(true)\n        resetFirstAndSecondCards();\n        setTries(0)\n        setMatchedCards([])\n    }\n\n\n\n    useEffect(() => {\n        initialize()\n    }, []);\n\n\n    useEffect(() => {\n        if (!firstCard || !secondCard)\n            return;\n        (firstCard.imageURL === secondCard.imageURL) ? onSuccessGuess() : onFailureGuess();\n        getScore()\n\n    }, [firstCard, secondCard])\n\n    useEffect(() => {\n        if(matchedCards.length === size/2) {\n            // to control the end result message\n            setEnd(true)\n        }\n    }, [matchedCards]);\n\n\n\n    useEffect(() => {\n        // to control the result message\n        if(!start && !secondCard && firstCard) {\n            setStart(true)\n        }\n    }, [firstCard]);\n\n\n    return (\n        <div>\n            <div className=\"header\">\n               <div className=\"result\">\n                   {\n                       start ? end? \"Congratulation ! You found all pairs\" :\n                           `You found ${matchedCards.length} out of ${size / 2 } pairs with ${tries} tries  `\n                           : \"Find All The Pairs\"\n                   }\n               </div>\n\n                <div className=\"restart\">\n                    <button onClick={()=>restart()}>Restart</button>\n                </div>\n            </div>\n            <div className=\"playground\">\n                {cards.map(card => <Card onClick={() => onCardClick(card)} key={card.id} {...card}/>)}\n            </div>\n        </div>)\n\n}\n\n\nexport default GamePlayGround\n","import React from 'react';\n\nimport './App.scss';\nimport cardImages from './cardImages';\n\nimport GamePlayGround from \"./components/GamePlayGround\";\n\nfunction App() {\n\n  return (\n    <div className=\"\">\n      <GamePlayGround cardImages={cardImages}/>\n    </div>\n  );\n}\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}